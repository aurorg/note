# 第八章：图

## 第一部分：图的相关概念

### 1.图的定义与基本术语

图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成的，通常表示为：G（V,E），其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。

V：顶点（数据元素）的有穷非空集合；

E：边的有穷集合。

2.无向图

3.有向图

4.完全图：任意两个点都有一条边相连。

无向完全图：n个顶点，有n(n-1)/2条边；

有向完全图：n个顶点，有n(n-1)条边。

5.稀疏图

有很少边或弧的图（e<nlogn）

6.稠密图

有较多边或弧的图；

7.网

边/弧带权的图

8.邻接

有边/弧相连的两个顶点之间的关系

9.关联(依附)

边/弧与顶点之间的关系

10.顶点的度

与该顶点相关联的边的数目，记为TD(v)

出度、入度

！！当有向图中仅1个顶点的入度为0，其余顶点的入度均为1，此时：是一颗有向树！

11.路径

接续的边构成的顶点序列；

12.路径长度

路径上边或弧的数目/权值之和。

13.回路（环）

第一个顶点和最后一个顶点相同的路径。

14.简单路径

除路径起点和终点可以相同外，其余顶点均不相同的路径。

15.连通图（强连通图）

在无（有）向图G=（V，{E}）中，若对任何两个顶点V,U都存在从v到u的路径，则称连通图（强连通图）。

16.子图

设有两个图G=（V，{E}）、G1=（V1，{E1}），若V1∈V，E1∈E，则称G1是G的子图。

17.连通分量（强连通分量）

无向图G的极大连通子图称为G的连通分量。

极大连通子图意思是：该子图是G连通子图，将G的任何不在该子图中的顶点加入，子图不再连通。

有向图G的极大强连通子图称为G的强连通分量。

极大强连通子图意思是：该子图是G强连通子图，将G的任何不在该子图中的顶点加入，子图不再是强连通。

18.极小连通子图：

该子图是G的连通子图，在该子图中删除任何一条边，子图不再连通。

19.生成树

包含无向图G所有顶点的极小连通子图

20.生成森林

对非连通图，由各个连通分了吧的生成树的集合。

## 第二部分：图的存储结构

##  1.邻接矩阵

```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXVEX 100  //最大顶点数
#define INFINITY 65535 //用65535代表无穷大

typedef int Status; //状态
typedef char VertexType; // 顶点类型由用户定义
typedef int EdgeType; // 边上的权值类型由用户定义

typedef struct{
    VertexType vexs[MAXVEX];//顶点表
    EdgeType arc[MAXVEX][MAXVEX];//邻接矩阵，可以看做边表
    int numVertexes, numEdges; //图中当前的顶点数和边数
} MGraph;


//建立无向网图的邻接矩阵表示
void CreateMGraph(MGraph *G){
    int i, j, k, w;
    printf("请输入顶点数和边数：\n");
    scanf("%d,%d", &G->numVertexes, &G->numEdges); //输入顶点数和边数
    for (i = 1; i < G->numVertexes;i++){  //读入顶点信息，建立顶点表
        scanf(&G->vexs[i]);  
    }
    for (i = 0; i < G->numVertexes;i++){
        for (j = 0; j < G->numVertexes;j++){
            G->arc[i][j] = INFINITY;  //邻接矩阵初始化
        }
    }

    for (k = 0; k < G->numEdges;k++){  //读入numEdges条边，建立邻接矩阵
        printf("输入边（vi,vj）上的下标i，下标j和权值w：\n");
        scanf("%d,%d,%d", &i, &j, &w);
        G->arc[i][j] = w;
        G->arc[j][i] = G->arc[i][j];  //因为是无向图，矩阵对称
    }
}


int main(void)
{    
	MGraph G;    
	CreateMGraph(&G);
	
	return 0;
}
```

## 2.邻接表

```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERORR 0
#define TRUE 1
#define FALSE 0
#define MAXVEX 100 /* 最大顶点数,应由用户定义 */

typedef int Status;	/* Status是函数的类型,其值是函数结果状态代码,如OK等 */
typedef char VertexType; /* 顶点类型应由用户定义 */
typedef int EdgeType; /* 边上的权值类型应由用户定义 */

typedef struct EdgeNode {  //边表结点
    int adjvex; //邻接点域，存储该顶点对应的下标
    EdgeType weight;  //用于存储权值，对于非网图可以不需要
    struct EdgeNode *next; //链域，指向下一个邻接点
} EdgeNode;

typedef struct VertexNode{   //顶点表结点
    VertexType data; //顶点域，存储顶点信息
    EdgeNode *firstedge; //边表头指针
} VertexNode, AdjList[MAXVEX];

typedef struct {
    AdjList adjList;
    int numNodes, numEdges;  //图中当前顶点数和边数
} GraphAdjList;


//建立图的邻接表结构
void CreateALGraph(GraphAdjList *G){
    int i, j, k;
    EdgeNode *e;
    printf("输入顶点数和边数：\n");
    for (i = 0; i < G->numNodes;i++){
        scanf(&G->adjList[i].data); //输入顶点信息
        G->adjList[i].firstedge = NULL; //将边表置为空表
    }

    for (k = 0; k < G->numEdges;k++){
        printf("输入边（vi,vj）上的顶点序号：\n");
        scanf("%d,%d", &i, &j); //输入边（vi,vj）上的顶点序号
       
        e = (EdgeNode *)malloc(sizeof(EdgeNode)); //向内存申请空间，生成边表结点
        e->adjvex = j;  //邻接序号为j
        e->next = G->adjList[i].firstedge; //将e的指针指向当前顶点上指向的结点
        G->adjList[i].firstedge = e; //将当前顶点的指针指向e

        e = (EdgeNode *)malloc(sizeof(EdgeNode)); //向内存申请空间，生成边表结点
        e->adjvex = i; //邻接序号为i
        e->next = G->adjList[j].firstedge; //将e的指针指向当前顶点上指向的结点
        G->adjList[j].firstedge = e; //将当前顶点的指针指向e
    }
}

int main(void){
    GraphAdjList G;
    CreateALGraph(&G);

    return 0;
}

```

## 第三部分：图的遍历

### 1.邻接矩阵深度和广度遍历



### 2.邻接表深度和广度遍历



## 第四部分：图的应用

1. 最小生成树

   普里姆算法

   克鲁斯卡尔算法

2. 最短路径

   Dijkstra

   floyd

3. 关键路径

4. 拓扑排序
