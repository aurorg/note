# 第八章：图

## 第一部分：图的定义与基本术语

- 1.图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成的，通常表示为：G（V,E），其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。

  V：顶点（数据元素）的有穷非空集合；

  E：边的有穷集合。

- 2.无向图

- 3.有向图

- 4.完全图：任意两个点都有一条边相连。

  无向完全图：n个顶点，有n(n-1)/2条边；

  有向完全图：n个顶点，有n(n-1)条边。

- 5.稀疏图

  有很少边或弧的图（e<nlogn）

- 6.稠密图

  有较多边或弧的图；

- 7.网

  边/弧带权的图

- 8.邻接

  有边/弧相连的两个顶点之间的关系

- 9.关联(依附)

  边/弧与顶点之间的关系

- 10.顶点的度

  与该顶点相关联的边的数目，记为TD(v)

  出度、入度

  ！！当有向图中仅1个顶点的入度为0，其余顶点的入度均为1，此时：是一颗有向树！

- 11.路径

  接续的边构成的顶点序列；

- 12.路径长度

  路径上边或弧的数目/权值之和。

- 13.回路（环）

  第一个顶点和最后一个顶点相同的路径。

- 14.简单路径

  除路径起点和终点可以相同外，其余顶点均不相同的路径。

- 15.连通图（强连通图）

  在无（有）向图G=（V，{E}）中，若对任何两个顶点V,U都存在从v到u的路径，则称连通图（强连通图）。

- 16.子图

  设有两个图G=（V，{E}）、G1=（V1，{E1}），若V1∈V，E1∈E，则称G1是G的子图。

- 17.连通分量（强连通分量）

  无向图G的极大连通子图称为G的连通分量。

  极大连通子图意思是：该子图是G连通子图，将G的任何不在该子图中的顶点加入，子图不再连通。

  有向图G的极大强连通子图称为G的强连通分量。

  极大强连通子图意思是：该子图是G强连通子图，将G的任何不在该子图中的顶点加入，子图不再是强连通。

- 18.极小连通子图：

  该子图是G的连通子图，在该子图中删除任何一条边，子图不再连通。

- 19.生成树

  包含无向图G所有顶点的极小连通子图

- 20.生成森林

  对非连通图，由各个连通分了吧的生成树的集合。   

## 第二部分：图的存储

### 1.邻接矩阵

```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXVEX 100  //最大顶点数
#define INFINITY 65535 //用65535代表无穷大

typedef int Status; //状态
typedef char VertexType; // 顶点类型由用户定义
typedef int EdgeType; // 边上的权值类型由用户定义

typedef struct{
    VertexType vexs[MAXVEX];//顶点表
    EdgeType arc[MAXVEX][MAXVEX];//邻接矩阵，可以看做边表
    int numVertexes, numEdges; //图中当前的顶点数和边数
} MGraph;


//建立无向网图的邻接矩阵表示
void CreateMGraph(MGraph *G){
    int i, j, k, w;
    printf("请输入顶点数和边数：\n");
    scanf("%d,%d", &G->numVertexes, &G->numEdges); //输入顶点数和边数
    for (i = 1; i < G->numVertexes;i++){  //读入顶点信息，建立顶点表
        scanf(&G->vexs[i]);  
    }
    for (i = 0; i < G->numVertexes;i++){
        for (j = 0; j < G->numVertexes;j++){
            G->arc[i][j] = INFINITY;  //邻接矩阵初始化
        }
    }

    for (k = 0; k < G->numEdges;k++){  //读入numEdges条边，建立邻接矩阵
        printf("输入边（vi,vj）上的下标i，下标j和权值w：\n");
        scanf("%d,%d,%d", &i, &j, &w);
        G->arc[i][j] = w;
        G->arc[j][i] = G->arc[i][j];  //因为是无向图，矩阵对称
    }
}


int main(void)
{    
	MGraph G;    
	CreateMGraph(&G);
	
	return 0;
}
```

### 2.邻接表

```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERORR 0
#define TRUE 1
#define FALSE 0
#define MAXVEX 100 /* 最大顶点数,应由用户定义 */

typedef int Status;	/* Status是函数的类型,其值是函数结果状态代码,如OK等 */
typedef char VertexType; /* 顶点类型应由用户定义 */
typedef int EdgeType; /* 边上的权值类型应由用户定义 */

typedef struct EdgeNode {  //边表结点
    int adjvex; //邻接点域，存储该顶点对应的下标
    EdgeType weight;  //用于存储权值，对于非网图可以不需要
    struct EdgeNode *next; //链域，指向下一个邻接点
} EdgeNode;

typedef struct VertexNode{   //顶点表结点
    VertexType data; //顶点域，存储顶点信息
    EdgeNode *firstedge; //边表头指针
} VertexNode, AdjList[MAXVEX];

typedef struct {
    AdjList adjList;
    int numNodes, numEdges;  //图中当前顶点数和边数
} GraphAdjList;


//建立图的邻接表结构
void CreateALGraph(GraphAdjList *G){
    int i, j, k;
    EdgeNode *e;
    printf("输入顶点数和边数：\n");
    for (i = 0; i < G->numNodes;i++){
        scanf(&G->adjList[i].data); //输入顶点信息
        G->adjList[i].firstedge = NULL; //将边表置为空表
    }

    for (k = 0; k < G->numEdges;k++){
        printf("输入边（vi,vj）上的顶点序号：\n");
        scanf("%d,%d", &i, &j); //输入边（vi,vj）上的顶点序号
       
        e = (EdgeNode *)malloc(sizeof(EdgeNode)); //向内存申请空间，生成边表结点
        e->adjvex = j;  //邻接序号为j
        e->next = G->adjList[i].firstedge; //将e的指针指向当前顶点上指向的结点
        G->adjList[i].firstedge = e; //将当前顶点的指针指向e

        e = (EdgeNode *)malloc(sizeof(EdgeNode)); //向内存申请空间，生成边表结点
        e->adjvex = i; //邻接序号为i
        e->next = G->adjList[j].firstedge; //将e的指针指向当前顶点上指向的结点
        G->adjList[j].firstedge = e; //将当前顶点的指针指向e
    }
}

int main(void){
    GraphAdjList G;
    CreateALGraph(&G);

    return 0;
}

```

## 第三部分：图的遍历

![](/home/shizhanli/微信图片_20230215120634.jpg)

![微信图片_20230215120649](/home/shizhanli/微信图片_20230215120649.jpg)



![微信图片_20230215120716](/home/shizhanli/微信图片_20230215120716.jpg)

![微信图片_20230215120722](/home/shizhanli/微信图片_20230215120722.jpg)

![微信图片_20230215120750](/home/shizhanli/微信图片_20230215120750.jpg)



![微信图片_20230215120739](/home/shizhanli/微信图片_20230215120739.jpg)

![微信图片_20230215120744](/home/shizhanli/微信图片_20230215120744.jpg)



### 1.邻接矩阵深度和广度遍历

```c
#include <stdio.h>
#include <stdlib.h>


#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0

typedef int Status;	/* Status是函数的类型,其值是函数结果状态代码，如OK等 */  
typedef int Boolean; /* Boolean是布尔类型,其值是TRUE或FALSE */

typedef char VertexType; /* 顶点类型应由用户定义 */
typedef int EdgeType; /* 边上的权值类型应由用户定义 */

#define MAXSIZE 9 /* 存储空间初始分配量 */
#define MAXEDGE 15
#define MAXVEX 9
#define INFINITY 65535

typedef struct{
	VertexType vexs[MAXVEX]; //顶点表
	EdgeType arc[MAXVEX][MAXVEX]; //邻接矩阵，可看做边表
	int numVertexes, numEdges; //图中当前顶点数和边数
} MGraph;

//用到的队列结构与函数

//循环队列的顺序存储结构
typedef struct{
	int data[MAXSIZE];
	int front; //头指针
	int rear; //尾指针，若队列为空，指向队列尾元素的下一个位置
} Queue;

//初始化一个空队列Q
Status InitQueue(Queue *Q){
	Q->front = 0;
	Q->rear = 0;
	return OK;
}

//若队列为空队列，则返回TRUE,否则返回FALSE
Status QueueEmpty(Queue Q){
	if(Q.front==Q.rear){  //队列空的标志
		return TRUE;
	}else{
		return FALSE;
	}
}

//入队！！！
//若队列未满，则插入元素e为Q新的队尾元素
Status EnQueue(Queue *Q,int e){
	if((Q->rear+1)%MAXSIZE==Q->front){ //队列满的判断
		return ERROR;
	}
	Q->data[Q->rear] = e;
	Q->rear = (Q->rear + 1) % MAXSIZE; //rear指针向后移动一位
	                                    //若到最后则转到数组头部

	return OK;
}


//出队！！！
//若队列不空，则删除Q中的队头元素，用e返回其值
Status DeQueue(Queue *Q,int *e){
	if(Q->front==Q->rear){      // 队列空的判断
		return ERROR;
	}
	*e = Q->data[Q->front];
	Q->front = (Q->front + 1) % MAXSIZE; //front指针向后移动一位
                                         //若到最后则转到数组头部
	return OK;
}

void CreateMGraph(MGraph *G)
{
	int i, j;

	G->numEdges=15;
	G->numVertexes=9;

	/* 读入顶点信息，建立顶点表 */
	G->vexs[0]='A';
	G->vexs[1]='B';
	G->vexs[2]='C';
	G->vexs[3]='D';
	G->vexs[4]='E';
	G->vexs[5]='F';
	G->vexs[6]='G';
	G->vexs[7]='H';
	G->vexs[8]='I';


	for (i = 0; i < G->numVertexes; i++)/* 初始化图 */
	{
		for ( j = 0; j < G->numVertexes; j++)
		{
			G->arc[i][j]=0;
		}
	}

	G->arc[0][1]=1;
	G->arc[0][5]=1;

	G->arc[1][2]=1; 
	G->arc[1][8]=1; 
	G->arc[1][6]=1; 
	
	G->arc[2][3]=1; 
	G->arc[2][8]=1; 
	
	G->arc[3][4]=1;
	G->arc[3][7]=1;
	G->arc[3][6]=1;
	G->arc[3][8]=1;

	G->arc[4][5]=1;
	G->arc[4][7]=1;

	G->arc[5][6]=1; 
	
	G->arc[6][7]=1; 

	
	for(i = 0; i < G->numVertexes; i++)
	{
		for(j = i; j < G->numVertexes; j++)
		{
			G->arc[j][i] =G->arc[i][j];
		}
	}

}
 
Boolean visited[MAXVEX]; /* 访问标志的数组 */


//邻接矩阵的深度优先递归算法
void DFS(MGraph G,int i){
	int j;
	visited[i] = TRUE;
	printf("%c ", G.vexs[i]); //打印顶点，也可以其它操作
	for (j = 0; j < G.numVertexes;j++){
		if(G.arc[i][j]==1 &&!visited[j]){
			DFS(G, j);
		}
	}
}

//邻接矩阵的深度遍历操作
void DFSTraverse(MGraph G){
	int i;
	for (i = 0; i < G.numVertexes;i++){
		visited[i] = FALSE; //初始所有顶点状态都是未访问过的状态
	}
	for (i = 0; i < G.numVertexes;i++){
		if(!visited[i]){
			DFS(G, i);
		}
	}
}

//邻接矩阵的广度遍历算法
void BFSTraverse(MGraph G){
	int i, j;
	Queue Q;
	for (i = 0; i < G.numVertexes;i++){
		visited[i] = FALSE;
	}
	InitQueue(&Q); //初始化一辅助用的队列
	for (i = 0; i < G.numVertexes;i++){  //对每一个顶点做循环
		if(!visited[i]){
			visited[i] = TRUE; //设置当前顶点访问过
			printf("%c ", G.vexs[i]); //打印顶点，也可以其他操作
			EnQueue(&Q, i); //将此顶点入队列
			while(!QueueEmpty(Q)){ //若当前队列不为空
				DeQueue(&Q, &i); //将队中元素出队列，赋值给i
				for (j = 0; j < G.numVertexes;j++){
					
					//判断其他顶点若与当前顶点存在边且未访问过
					if(G.arc[i][j]==1 &&!visited[j]){
						visited[j] = TRUE;   /* 将找到的此顶点标记为已访问 */
						printf("%c ", G.vexs[j]); //打印顶点
						EnQueue(&Q, j);   /* 将找到的此顶点入队列  */ 
					}

				}
			}
		}
	}
}

int main(void)
{    
	MGraph G;
	CreateMGraph(&G);
	printf("\n深度遍历：");
	DFSTraverse(G);
	printf("\n广度遍历：");
	BFSTraverse(G);
	return 0;
}

```

### 2.邻接表深度和广度遍历

```c
#include <stdio.h>
#include <stdlib.h>


#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0

#define MAXSIZE 9 /* 存储空间初始分配量 */
#define MAXEDGE 15
#define MAXVEX 9
#define INFINITY 65535

typedef int Status;	/* Status是函数的类型,其值是函数结果状态代码,如OK等 */
typedef int Boolean; /* Boolean是布尔类型,其值是TRUE或FALSE */

typedef char VertexType; /* 顶点类型应由用户定义 */   
typedef int EdgeType; /* 边上的权值类型应由用户定义 */

/* 邻接矩阵结构 */
typedef struct
{
	VertexType vexs[MAXVEX]; /* 顶点表 */
	EdgeType arc[MAXVEX][MAXVEX];/* 邻接矩阵,可看作边表 */
	int numVertexes, numEdges; /* 图中当前的顶点数和边数 */ 
}MGraph;

/* 邻接表结构****************** */
typedef struct EdgeNode /* 边表结点 */ 
{
	int adjvex;    /* 邻接点域,存储该顶点对应的下标 */
	int weight;		/* 用于存储权值,对于非网图可以不需要 */
	struct EdgeNode *next; /* 链域,指向下一个邻接点 */ 
}EdgeNode;

typedef struct VertexNode /* 顶点表结点 */ 
{
	int in;	/* 顶点入度 */
	char data; /* 顶点域,存储顶点信息 */
	EdgeNode *firstedge;/* 边表头指针 */   
}VertexNode, AdjList[MAXVEX];

typedef struct
{
	AdjList adjList; 
	int numVertexes,numEdges; /* 图中当前顶点数和边数 */
}graphAdjList,*GraphAdjList;
/* **************************** */

/* 用到的队列结构与函数********************************** */
/* 循环队列的顺序存储结构 */
typedef struct
{
	int data[MAXSIZE];
	int front;    	/* 头指针 */
	int rear;		/* 尾指针,若队列不空,指向队列尾元素的下一个位置 */
}Queue;

/* 初始化一个空队列Q */
Status InitQueue(Queue *Q)
{
	Q->front=0;
	Q->rear=0;
	return  OK;
}

/* 若队列Q为空队列,则返回TRUE,否则返回FALSE */
Status QueueEmpty(Queue Q)
{ 
	if(Q.front==Q.rear) /* 队列空的标志 */
		return TRUE;
	else
		return FALSE;
}

/* 若队列未满,则插入元素e为Q新的队尾元素 */
Status EnQueue(Queue *Q,int e)
{
	if ((Q->rear+1)%MAXSIZE == Q->front)	/* 队列满的判断 */
		return ERROR;
	Q->data[Q->rear]=e;			/* 将元素e赋值给队尾 */
	Q->rear=(Q->rear+1)%MAXSIZE;/* rear指针向后移一位置, */
								/* 若到最后则转到数组头部 */
	return  OK;
}

/* 若队列不空,则删除Q中队头元素,用e返回其值 */
Status DeQueue(Queue *Q,int *e)
{
	if (Q->front == Q->rear)			/* 队列空的判断 */
		return ERROR;
	*e=Q->data[Q->front];				/* 将队头元素赋值给e */
	Q->front=(Q->front+1)%MAXSIZE;	/* front指针向后移一位置, */
									/* 若到最后则转到数组头部 */
	return  OK;
}
/* ****************************************************** */



void CreateMGraph(MGraph *G)
{
	int i, j;

	G->numEdges=15;
	G->numVertexes=9;

	/* 读入顶点信息,建立顶点表 */ 
	G->vexs[0]='A';
	G->vexs[1]='B';
	G->vexs[2]='C';
	G->vexs[3]='D';
	G->vexs[4]='E';
	G->vexs[5]='F';
	G->vexs[6]='G';
	G->vexs[7]='H';
	G->vexs[8]='I';


	for (i = 0; i < G->numVertexes; i++)/* 初始化图 */
	{
		for ( j = 0; j < G->numVertexes; j++)
		{
			G->arc[i][j]=0;
		}
	}

	G->arc[0][1]=1;
	G->arc[0][5]=1;

	G->arc[1][2]=1; 
	G->arc[1][8]=1; 
	G->arc[1][6]=1; 
	
	G->arc[2][3]=1; 
	G->arc[2][8]=1; 
	
	G->arc[3][4]=1;
	G->arc[3][7]=1;
	G->arc[3][6]=1;
	G->arc[3][8]=1;

	G->arc[4][5]=1;
	G->arc[4][7]=1;

	G->arc[5][6]=1; 
	
	G->arc[6][7]=1; 

	
	for(i = 0; i < G->numVertexes; i++)
	{
		for(j = i; j < G->numVertexes; j++)
		{
			G->arc[j][i] =G->arc[i][j];
		}
	}

}
 
/* 利用邻接矩阵构建邻接表 */
void CreateALGraph(MGraph G,GraphAdjList *GL)
{
	int i,j;
	EdgeNode *e;

	*GL = (GraphAdjList)malloc(sizeof(graphAdjList));

	(*GL)->numVertexes=G.numVertexes;
	(*GL)->numEdges=G.numEdges;
	for(i= 0;i <G.numVertexes;i++) /* 读入顶点信息,建立顶点表 */   
	{
		(*GL)->adjList[i].in=0;
		(*GL)->adjList[i].data=G.vexs[i];
		(*GL)->adjList[i].firstedge=NULL; 	/* 将边表置为空表 */
	}
	
	for(i=0;i<G.numVertexes;i++) /* 建立边表 */
	{ 
		for(j=0;j<G.numVertexes;j++)
		{
			if (G.arc[i][j]==1)
			{
				e=(EdgeNode *)malloc(sizeof(EdgeNode));
				e->adjvex=j;					/* 邻接序号为j */                         
				e->next=(*GL)->adjList[i].firstedge;	/* 将当前顶点上的指向的结点指针赋值给e */
				(*GL)->adjList[i].firstedge=e;		/* 将当前顶点的指针指向e */   
				(*GL)->adjList[j].in++;
				
			}
		}
	}
	
}

Boolean visited[MAXSIZE]; /* 访问标志的数组 */

/* 邻接表的深度优先递归算法 */
void DFS(GraphAdjList GL, int i)
{
	EdgeNode *p;
 	visited[i] = TRUE;
 	printf("%c ",GL->adjList[i].data);/* 打印顶点,也可以其它操作 */
	p = GL->adjList[i].firstedge;
	while(p)
	{
 		if(!visited[p->adjvex])
 			DFS(GL, p->adjvex);/* 对为访问的邻接顶点递归调用 */
		p = p->next;
 	}
}

/* 邻接表的深度遍历操作 */
void DFSTraverse(GraphAdjList GL)
{
	int i;
 	for(i = 0; i < GL->numVertexes; i++)
 		visited[i] = FALSE; /* 初始所有顶点状态都是未访问过状态 */
	for(i = 0; i < GL->numVertexes; i++)
 		if(!visited[i]) /* 对未访问过的顶点调用DFS,若是连通图,只会执行一次 */ 
			DFS(GL, i);
}

/* 邻接表的广度遍历算法 */
void BFSTraverse(GraphAdjList GL)
{
	int i;
    EdgeNode *p;
	Queue Q;
	for(i = 0; i < GL->numVertexes; i++)
       	visited[i] = FALSE;
    InitQueue(&Q);
   	for(i = 0; i < GL->numVertexes; i++)
   	{
		if (!visited[i])
		{
			visited[i]=TRUE;
			printf("%c ",GL->adjList[i].data);/* 打印顶点,也可以其它操作 */
			EnQueue(&Q,i);
			while(!QueueEmpty(Q))
			{
				DeQueue(&Q,&i);
				p = GL->adjList[i].firstedge;	/* 找到当前顶点的边表链表头指针 */
				while(p)
				{
					if(!visited[p->adjvex])	/* 若此顶点未被访问 */
 					{
 						visited[p->adjvex]=TRUE;
						printf("%c ",GL->adjList[p->adjvex].data);
						EnQueue(&Q,p->adjvex);	/* 将此顶点入队列 */
					}
					p = p->next;	/* 指针指向下一个邻接点 */
				}
			}
		}
	}
}

int main(void)
{    
	MGraph G;  
	GraphAdjList GL;    
	CreateMGraph(&G);
	CreateALGraph(G,&GL);

	printf("\n深度遍历:");
	DFSTraverse(GL);
	printf("\n广度遍历:");
	BFSTraverse(GL);
	return 0;
}
```



## 第四部分：图的应用

### 1.最小生成树

1.生成树的概念

![微信图片_20230216113014](/home/shizhanli/微信图片_20230216113014.png)



![微信图片_20230216113032](/home/shizhanli/微信图片_20230216113032.png)

2.无向图的生成树![微信图片_20230216113038](/home/shizhanli/微信图片_20230216113038.png)

3.最小生成树

![微信图片_20230216113043](/home/shizhanli/微信图片_20230216113043.png)

4.最小生成树的用途

![微信图片_20230216113103](/home/shizhanli/微信图片_20230216113103.png)

5.构造最小生成树

![微信图片_20230216113109](/home/shizhanli/微信图片_20230216113109.png)

![微信图片_20230216113114](/home/shizhanli/微信图片_20230216113114.png)

#### 1>.普里姆算法（Prim）

![微信图片_20230216113119](/home/shizhanli/微信图片_20230216113119.png)



代码

```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0

#define MAXEDGE 20
#define MAXVEX 20
#define INFINITY 65535

typedef int Status;	/* Status是函数的类型,其值是函数结果状态代码，如OK等 */

typedef struct
{
	int arc[MAXVEX][MAXVEX];
	int numVertexes, numEdges;
}MGraph;

void CreateMGraph(MGraph *G)/* 构件图 */
{
	int i, j;

	/* printf("请输入边数和顶点数:"); */
	G->numEdges=15;
	G->numVertexes=9;

	for (i = 0; i < G->numVertexes; i++)/* 初始化图 */
	{
		for ( j = 0; j < G->numVertexes; j++)
		{
			if (i==j)
				G->arc[i][j]=0;
			else
				G->arc[i][j] = G->arc[j][i] = INFINITY;
		}
	}

	G->arc[0][1]=10;
	G->arc[0][5]=11; 
	G->arc[1][2]=18; 
	G->arc[1][8]=12; 
	G->arc[1][6]=16; 
	G->arc[2][8]=8; 
	G->arc[2][3]=22; 
	G->arc[3][8]=21; 
	G->arc[3][6]=24; 
	G->arc[3][7]=16;
	G->arc[3][4]=20;
	G->arc[4][7]=7; 
	G->arc[4][5]=26; 
	G->arc[5][6]=17; 
	G->arc[6][7]=19; 

	for(i = 0; i < G->numVertexes; i++)
	{
		for(j = i; j < G->numVertexes; j++)
		{
			G->arc[j][i] =G->arc[i][j];
		}
	}

}

/* Prim算法生成最小生成树  */
void MiniSpanTree_Prim(MGraph G)
{
	int min, i, j, k;
	int adjvex[MAXVEX];		/* 保存相关顶点下标 */
	int lowcost[MAXVEX];	/* 保存相关顶点间边的权值 */
	lowcost[0] = 0;/* 初始化第一个权值为0，即v0加入生成树 */
			/* lowcost的值为0，在这里就是此下标的顶点已经加入生成树 */
	adjvex[0] = 0;			/* 初始化第一个顶点下标为0 */
	for(i = 1; i < G.numVertexes; i++)	/* 循环除下标为0外的全部顶点 */
	{
		lowcost[i] = G.arc[0][i];	/* 将v0顶点与之有边的权值存入数组 */
		adjvex[i] = 0;					/* 初始化都为v0的下标 */
	}
	for(i = 1; i < G.numVertexes; i++)
	{
		min = INFINITY;	/* 初始化最小权值为∞， */
						/* 通常设置为不可能的大数字如32767、65535等 */
		j = 1;k = 0;
		while(j < G.numVertexes)	/* 循环全部顶点 */
		{
			if(lowcost[j]!=0 && lowcost[j] < min)/* 如果权值不为0且权值小于min */
			{	
				min = lowcost[j];	/* 则让当前权值成为最小值 */
				k = j;			/* 将当前最小值的下标存入k */
			}
			j++;
		}
		printf("(%d, %d)\n", adjvex[k], k);/* 打印当前顶点边中权值最小的边 */
		lowcost[k] = 0;/* 将当前顶点的权值设置为0,表示此顶点已经完成任务 */
		for(j = 1; j < G.numVertexes; j++)	/* 循环所有顶点 */
		{
			if(lowcost[j]!=0 && G.arc[k][j] < lowcost[j]) 
			{/* 如果下标为k顶点各边权值小于此前这些顶点未被加入生成树权值 */
				lowcost[j] = G.arc[k][j];/* 将较小的权值存入lowcost相应位置 */
				adjvex[j] = k;				/* 将下标为k的顶点存入adjvex */
			}
		}
	}
}

int main(void)
{
	MGraph G;
	CreateMGraph(&G);
	MiniSpanTree_Prim(G);
  
	return 0;
 
}
```



#### 2>.克鲁斯卡尔算法(Kruskal)

![微信图片_20230216113124](/home/shizhanli/微信图片_20230216113124.png)

代码

```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0

typedef int Status;	/* Status是函数的类型,其值是函数结果状态代码，如OK等 */

#define MAXEDGE 20
#define MAXVEX 20
#define INFINITY 65535

typedef struct
{
	int arc[MAXVEX][MAXVEX];
	int numVertexes, numEdges;
}MGraph;

typedef struct
{
	int begin;
	int end;
	int weight;
}Edge;   /* 对边集数组Edge结构的定义 */

/* 构件图 */
void CreateMGraph(MGraph *G)
{
	int i, j;

	/* printf("请输入边数和顶点数:"); */
	G->numEdges=15;
	G->numVertexes=9;

	for (i = 0; i < G->numVertexes; i++)/* 初始化图 */
	{
		for ( j = 0; j < G->numVertexes; j++)
		{
			if (i==j)
				G->arc[i][j]=0;
			else
				G->arc[i][j] = G->arc[j][i] = INFINITY;
		}
	}

	G->arc[0][1]=10;
	G->arc[0][5]=11; 
	G->arc[1][2]=18; 
	G->arc[1][8]=12; 
	G->arc[1][6]=16; 
	G->arc[2][8]=8; 
	G->arc[2][3]=22; 
	G->arc[3][8]=21; 
	G->arc[3][6]=24; 
	G->arc[3][7]=16;
	G->arc[3][4]=20;
	G->arc[4][7]=7; 
	G->arc[4][5]=26; 
	G->arc[5][6]=17; 
	G->arc[6][7]=19; 

	for(i = 0; i < G->numVertexes; i++)
	{
		for(j = i; j < G->numVertexes; j++)
		{
			G->arc[j][i] =G->arc[i][j];
		}
	}

}

/* 交换权值 以及头和尾 */
void Swapn(Edge *edges,int i, int j)
{
	int temp;
	temp = edges[i].begin;
	edges[i].begin = edges[j].begin;
	edges[j].begin = temp;
	temp = edges[i].end;
	edges[i].end = edges[j].end;
	edges[j].end = temp;
	temp = edges[i].weight;
	edges[i].weight = edges[j].weight;
	edges[j].weight = temp;
}

/* 对权值进行排序 */
void sort(Edge edges[],MGraph *G)
{
	int i, j;
	for ( i = 0; i < G->numEdges; i++)
	{
		for ( j = i + 1; j < G->numEdges; j++)
		{
			if (edges[i].weight > edges[j].weight)
			{
				Swapn(edges, i, j);
			}
		}
	}
	printf("权排序之后的为:\n");
	for (i = 0; i < G->numEdges; i++)
	{
		printf("(%d, %d) %d\n", edges[i].begin, edges[i].end, edges[i].weight);
	}

}

/* 查找连线顶点的尾部下标 */
int Find(int *parent, int f)
{
	while ( parent[f] > 0)
	{
		f = parent[f];
	}
	return f;
}

/* 生成最小生成树 */
void MiniSpanTree_Kruskal(MGraph G)
{
	int i, j, n, m;
	int k = 0;
	int parent[MAXVEX];/* 定义一数组用来判断边与边是否形成环路 */
	
	Edge edges[MAXEDGE];/* 定义边集数组,edge的结构为begin,end,weight,均为整型 */

	/* 用来构建边集数组并排序********************* */
	for ( i = 0; i < G.numVertexes-1; i++)
	{
		for (j = i + 1; j < G.numVertexes; j++)
		{
			if (G.arc[i][j]<INFINITY)
			{
				edges[k].begin = i;
				edges[k].end = j;
				edges[k].weight = G.arc[i][j];
				k++;
			}
		}
	}
	sort(edges, &G);
	/* ******************************************* */


	for (i = 0; i < G.numVertexes; i++)
		parent[i] = 0;	/* 初始化数组值为0 */

	printf("打印最小生成树：\n");
	for (i = 0; i < G.numEdges; i++)	/* 循环每一条边 */
	{
		n = Find(parent,edges[i].begin);
		m = Find(parent,edges[i].end);
		if (n != m) /* 假如n与m不等，说明此边没有与现有的生成树形成环路 */
		{
			parent[n] = m;	/* 将此边的结尾顶点放入下标为起点的parent中。 */
							/* 表示此顶点已经在生成树集合中 */
			printf("(%d, %d) %d\n", edges[i].begin, edges[i].end, edges[i].weight);
		}
	}
}

int main(void)
{
	MGraph G;
	CreateMGraph(&G);
	MiniSpanTree_Kruskal(G);
	return 0;
}
```



#### 3>.两种算法的比较

![微信图片_20230216113129](/home/shizhanli/微信图片_20230216113129.png)

### 2.最短路径

最短路径问题

![image-20230221151646264](/home/shizhanli/.config/Typora/typora-user-images/image-20230221151646264.png)

![image-20230221151706870](/home/shizhanli/.config/Typora/typora-user-images/image-20230221151706870.png)

![image-20230221151728269](/home/shizhanli/.config/Typora/typora-user-images/image-20230221151728269.png)

![image-20230221151742834](/home/shizhanli/.config/Typora/typora-user-images/image-20230221151742834.png)



![image-20230221151754095](/home/shizhanli/.config/Typora/typora-user-images/image-20230221151754095.png)

#### 1>.Dijkstra

![image-20230221151804770](/home/shizhanli/.config/Typora/typora-user-images/image-20230221151804770.png)



![image-20230221151822320](/home/shizhanli/.config/Typora/typora-user-images/image-20230221151822320.png)



![image-20230221151842109](/home/shizhanli/.config/Typora/typora-user-images/image-20230221151842109.png)



#### 2>.floyd

![image-20230221151925367](/home/shizhanli/.config/Typora/typora-user-images/image-20230221151925367.png)

![image-20230221151939067](/home/shizhanli/.config/Typora/typora-user-images/image-20230221151939067.png)

### 3.拓扑排序

![image-20230221193342483](/home/shizhanli/.config/Typora/typora-user-images/image-20230221193342483.png)

![image-20230221193355771](/home/shizhanli/.config/Typora/typora-user-images/image-20230221193355771.png)

![image-20230221193406665](/home/shizhanli/.config/Typora/typora-user-images/image-20230221193406665.png)

![image-20230221193418855](/home/shizhanli/.config/Typora/typora-user-images/image-20230221193418855.png)

![image-20230221193428905](/home/shizhanli/.config/Typora/typora-user-images/image-20230221193428905.png)

![image-20230221193441220](/home/shizhanli/.config/Typora/typora-user-images/image-20230221193441220.png)

![image-20230221193450407](/home/shizhanli/.config/Typora/typora-user-images/image-20230221193450407.png)

![image-20230221193502151](/home/shizhanli/.config/Typora/typora-user-images/image-20230221193502151.png)

![image-20230221193511285](/home/shizhanli/.config/Typora/typora-user-images/image-20230221193511285.png)

![image-20230221193518249](/home/shizhanli/.config/Typora/typora-user-images/image-20230221193518249.png)

![image-20230221193525429](/home/shizhanli/.config/Typora/typora-user-images/image-20230221193525429.png)

![image-20230221193535273](/home/shizhanli/.config/Typora/typora-user-images/image-20230221193535273.png)

![image-20230221193546161](/home/shizhanli/.config/Typora/typora-user-images/image-20230221193546161.png)

![image-20230221193552910](/home/shizhanli/.config/Typora/typora-user-images/image-20230221193552910.png)

![image-20230221193603653](/home/shizhanli/.config/Typora/typora-user-images/image-20230221193603653.png)

![image-20230221193614774](/home/shizhanli/.config/Typora/typora-user-images/image-20230221193614774.png)

![image-20230221193629890](/home/shizhanli/.config/Typora/typora-user-images/image-20230221193629890.png)

### 4.关键路径
